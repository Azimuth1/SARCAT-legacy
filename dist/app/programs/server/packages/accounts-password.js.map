{"version":3,"sources":["accounts-password/email_templates.js","accounts-password/password_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,sE;AACA,gB;AACA,G;AACA,2B;AACA,gD;AACA,gF;;AAEA,kB;AACA,6B;AACA,iF;AACA,M;AACA,+B;AACA,0D;AACA,4D;AACA,4B;AACA,c;AACA,kE;AACA,c;AACA,oB;AACA,c;AACA,sB;AACA,K;AACA,I;AACA,gB;AACA,6B;AACA,kF;AACA,M;AACA,+B;AACA,0D;AACA,4D;AACA,4B;AACA,c;AACA,wE;AACA,c;AACA,oB;AACA,c;AACA,sB;AACA,K;AACA,I;AACA,kB;AACA,6B;AACA,0F;AACA,M;AACA,+B;AACA,0D;AACA,4D;AACA,4B;AACA,c;AACA,sE;AACA,c;AACA,oB;AACA,c;AACA,sB;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACxDA,U;;AAEA,6B;AACA,+C;AACA,qD;;AAEA,uE;AACA,qE;AACA,qE;AACA,gB;AACA,E;AACA,qE;AACA,sE;AACA,0E;AACA,wE;AACA,qE;AACA,W;AACA,E;AACA,uE;AACA,uE;AACA,qE;AACA,kD;;;AAGA,4B;;AAEA,wE;AACA,oC;AACA,qC;AACA,+E;AACA,E;AACA,6C;AACA,qC;AACA,gC;AACA,qC;AACA,2C;AACA,2D;AACA,oD;AACA,K;AACA,+B;AACA,G;AACA,kB;AACA,E;;AAEA,+D;AACA,mE;AACA,kE;AACA,2D;AACA,E;AACA,wC;AACA,yC;AACA,sD;AACA,E;;AAEA,wE;AACA,sE;AACA,iE;AACA,+D;AACA,sB;AACA,E;AACA,qD;AACA,gB;AACA,oB;AACA,I;;AAEA,yC;;AAEA,iE;AACA,+D;AACA,G;;AAEA,gB;AACA,E;AACA,4C;;AAEA,G;AACA,S;AACA,G;;AAEA,8D;AACA,iE;AACA,+D;;AAEA,6C;AACA,c;AACA,0B;AACA,yB;AACA,qC;AACA,sB;AACA,0C;AACA,oE;AACA,E;;AAEA,6C;AACA,6C;;AAEA,4C;AACA,Y;AACA,kD;;AAEA,c;AACA,E;;AAEA,8C;AACA,+C;AACA,mB;AACA,sB;AACA,G;;AAEA,sD;AACA,e;AACA,uC;AACA,6C;AACA,yC;AACA,K;AACA,gC;AACA,uE;AACA,c;AACA,G;;AAEA,oC;AACA,S;AACA,uC;AACA,E;;AAEA,oC;AACA,E;AACA,iE;AACA,kE;AACA,E;AACA,oE;AACA,uE;AACA,E;AACA,iE;AACA,yD;AACA,2B;AACA,E;AACA,2D;AACA,E;AACA,8D;AACA,wC;AACA,qC;;AAEA,kB;AACA,6B;AACA,+B;AACA,K;;;AAGA,iD;;AAEA,kD;AACA,qE;AACA,4D;;AAEA,uC;AACA,+C;AACA,uE;AACA,wE;AACA,mE;AACA,oD;AACA,gD;AACA,gE;AACA,2D;;AAEA,uD;AACA,gB;AACA,2B;AACA,4D;AACA,U;AACA,O;;AAEA,gC;AACA,Y;AACA,wD;AACA,0E;AACA,sB;AACA,qD;AACA,U;AACA,K;AACA,G;;AAEA,uB;AACA,S;AACA,oB;AACA,I;AACA,G;;AAEA,iE;AACA,oC;AACA,wC;AACA,+E;AACA,E;AACA,mE;AACA,sE;AACA,qE;AACA,iB;AACA,E;AACA,sE;AACA,qE;AACA,4B;AACA,E;AACA,0B;AACA,8D;AACA,wC;AACA,qC;;AAEA,kB;AACA,6B;AACA,gB;AACA,+B;AACA,K;;AAEA,iD;;AAEA,oE;AACA,+B;AACA,+E;AACA,iD;;AAEA,+E;AACA,4D;;AAEA,+C;AACA,gC;AACA,S;AACA,K;AACA,6C;AACA,2C;AACA,K;AACA,a;AACA,gB;AACA,Y;AACA,uB;AACA,wD;AACA,M;;AAEA,2C;AACA,8C;AACA,sB;AACA,a;AACA,K;AACA,6C;AACA,kD;AACA,K;AACA,I;;AAEA,4B;AACA,G;;;AAGA,G;AACA,Y;AACA,G;;AAEA,8D;AACA,wE;AACA,sE;AACA,E;AACA,0B;AACA,sE;AACA,mE;AACA,uE;AACA,2B;AACA,E;AACA,wE;AACA,mE;AACA,sE;AACA,mE;AACA,qB;AACA,qE;AACA,wC;AACA,wC;;AAEA,mB;AACA,qD;;AAEA,+C;AACA,Y;AACA,kD;;AAEA,kD;AACA,sE;AACA,4D;;AAEA,wC;AACA,wE;AACA,oB;AACA,mD;AACA,Q;AACA,G;;AAEA,gD;AACA,mB;AACA,uB;;AAEA,yC;;AAEA,wE;AACA,wE;AACA,wE;AACA,wC;AACA,iE;AACA,sB;AACA,yB;AACA,K;AACA,mD;AACA,c;AACA,6E;AACA,Q;AACA,8C;AACA,K;AACA,I;;AAEA,iC;AACA,I;;;AAGA,mC;;AAEA,G;AACA,oD;AACA,gB;AACA,uD;AACA,2D;AACA,4B;AACA,iG;AACA,G;AACA,yE;AACA,8C;;AAEA,0C;AACA,Y;AACA,kD;;AAEA,gB;AACA,a;AACA,4D;AACA,kC;AACA,M;AACA,0E;AACA,I;;AAEA,uB;AACA,qD;AACA,G;;AAEA,+C;AACA,E;;;AAGA,G;AACA,uB;AACA,G;;AAEA,qE;AACA,kC;AACA,oD;AACA,kC;;AAEA,qE;AACA,Y;AACA,kD;;AAEA,2D;AACA,I;;AAEA,sE;AACA,mD;;AAEA,G;AACA,+E;AACA,gB;AACA,8D;AACA,iL;AACA,G;AACA,4D;AACA,oE;AACA,0C;AACA,Y;AACA,uC;AACA,wD;AACA,8C;AACA,mC;AACA,oC;AACA,0E;AACA,+C;;AAEA,8B;AACA,wB;AACA,qB;AACA,iB;AACA,iB;AACA,c;AACA,I;AACA,sC;AACA,0C;AACA,M;AACA,kE;AACA,mE;;AAEA,4D;;AAEA,iB;AACA,c;AACA,oD;AACA,wD;AACA,qC;AACA,iE;AACA,4E;AACA,I;;AAEA,uE;AACA,kB;AACA,yE;;AAEA,4D;AACA,sD;AACA,G;;AAEA,sB;AACA,E;;AAEA,6E;AACA,6E;AACA,0E;AACA,2E;AACA,E;AACA,sE;AACA,iC;;AAEA,G;AACA,qF;AACA,gB;AACA,8D;AACA,iL;AACA,G;AACA,yD;AACA,yE;;AAEA,gE;AACA,0C;AACA,Y;AACA,uC;AACA,wD;AACA,8C;AACA,mC;AACA,oC;AACA,0E;AACA,+C;;AAEA,8B;AACA,wB;AACA,qB;AACA,iB;AACA,iB;AACA,c;AACA,I;AACA,sC;AACA,0C;AACA,M;;AAEA,kE;AACA,mE;;AAEA,4D;;AAEA,iB;AACA,c;AACA,oD;AACA,wD;AACA,qC;AACA,iE;AACA,4E;AACA,I;;AAEA,uE;AACA,kB;AACA,yE;;AAEA,4D;AACA,sD;AACA,G;;AAEA,sB;AACA,E;;;AAGA,wE;AACA,uC;AACA,8D;AACA,kB;AACA,+B;AACA,S;AACA,oB;AACA,c;AACA,e;AACA,iB;AACA,2B;AACA,4C;;AAEA,uC;AACA,iD;AACA,gB;AACA,qD;AACA,qD;AACA,mE;AACA,gB;AACA,2B;AACA,yE;AACA,U;;AAEA,6C;;AAEA,4E;AACA,uE;AACA,2E;AACA,kD;AACA,iE;AACA,+D;AACA,yC;AACA,qE;AACA,Q;;AAEA,W;AACA,qC;AACA,iD;AACA,gE;AACA,gF;AACA,kD;AACA,W;AACA,0B;AACA,oC;AACA,kD;AACA,Y;AACA,qD;AACA,6C;AACA,iD;AACA,kD;AACA,kC;AACA,kB;AACA,6B;AACA,yD;AACA,Y;AACA,qB;AACA,0B;AACA,kB;AACA,O;;AAEA,+D;AACA,uD;AACA,8C;;AAEA,gC;AACA,K;AACA,I;AACA,I;;AAEA,G;AACA,sB;AACA,G;;;AAGA,iE;AACA,sB;;AAEA,G;AACA,kF;AACA,gB;AACA,8D;AACA,4L;AACA,G;AACA,6D;AACA,iE;AACA,mE;AACA,kB;;AAEA,sE;AACA,0C;AACA,Y;AACA,uC;AACA,uE;AACA,iB;AACA,yC;AACA,6D;AACA,oC;AACA,G;AACA,sC;AACA,8E;AACA,uD;;;AAGA,qB;AACA,2B;AACA,qB;AACA,sB;AACA,sB;AACA,kB;AACA,iE;;AAEA,kE;AACA,4C;AACA,gD;AACA,gD;AACA,G;AACA,2D;;AAEA,oE;;AAEA,iB;AACA,gB;AACA,kD;AACA,sD;AACA,qC;AACA,+D;AACA,wE;AACA,I;;AAEA,qE;AACA,kB;AACA,qE;;AAEA,4D;AACA,sD;AACA,G;;AAEA,sB;AACA,E;;AAEA,qE;AACA,mB;AACA,+C;AACA,kB;AACA,+B;AACA,S;AACA,kB;AACA,c;AACA,e;AACA,iB;AACA,2B;;AAEA,sC;AACA,4D;AACA,gB;AACA,iE;;AAEA,sE;AACA,6C;AACA,yD;AACA,kC;AACA,uB;AACA,gB;AACA,2B;AACA,mE;AACA,U;;AAEA,2D;AACA,gD;AACA,S;AACA,wB;AACA,gB;AACA,2B;AACA,kF;AACA,U;;AAEA,4E;AACA,yE;AACA,mB;AACA,yF;AACA,sE;AACA,0B;AACA,uB;AACA,gD;AACA,2C;AACA,wE;;AAEA,gC;AACA,K;AACA,I;AACA,I;;;;AAIA,G;AACA,kB;AACA,G;;AAEA,qE;AACA,qE;AACA,kC;AACA,E;AACA,sB;AACA,qC;AACA,wE;AACA,a;AACA,wC;AACA,qC;AACA,kC;AACA,+C;AACA,M;;AAEA,kC;AACA,4B;AACA,0B;AACA,mE;;AAEA,4B;AACA,yB;AACA,gD;AACA,gD;AACA,G;;AAEA,e;AACA,6B;AACA,Y;AACA,sD;;AAEA,+C;AACA,E;;AAEA,yD;AACA,gD;AACA,kB;AACA,+B;AACA,S;AACA,iB;AACA,c;AACA,e;AACA,iB;AACA,+C;AACA,6B;AACA,wD;AACA,gB;AACA,2D;AACA,U;;AAEA,mD;AACA,uC;AACA,8E;AACA,mE;AACA,mB;AACA,gE;;AAEA,sE;AACA,mE;AACA,sB;AACA,mE;AACA,8D;;AAEA,0D;AACA,8B;AACA,K;AACA,I;AACA,I;;AAEA,sC;AACA,E;AACA,mE;AACA,kB;AACA,E;AACA,uD;AACA,E;AACA,8E;AACA,4E;AACA,8E;AACA,gD;AACA,E;AACA,oD;AACA,6B;;AAEA,oC;AACA,iB;AACA,0F;AACA,G;;AAEA,6B;AACA,E;;AAEA,G;AACA,sC;AACA,G;AACA,0D;AACA,kD;AACA,0D;AACA,kD","file":"/packages/accounts-password.js","sourcesContent":["/**\n * @summary Options to customize emails sent from the Accounts system.\n * @locus Server\n */\nAccounts.emailTemplates = {\n  from: \"Meteor Accounts <no-reply@meteor.com>\",\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),\n\n  resetPassword: {\n    subject: function(user) {\n      return \"How to reset your password on \" + Accounts.emailTemplates.siteName;\n    },\n    text: function(user, url) {\n      var greeting = (user.profile && user.profile.name) ?\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\n      return greeting + \"\\n\"\n        + \"\\n\"\n        + \"To reset your password, simply click the link below.\\n\"\n        + \"\\n\"\n        + url + \"\\n\"\n        + \"\\n\"\n        + \"Thanks.\\n\";\n    }\n  },\n  verifyEmail: {\n    subject: function(user) {\n      return \"How to verify email address on \" + Accounts.emailTemplates.siteName;\n    },\n    text: function(user, url) {\n      var greeting = (user.profile && user.profile.name) ?\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\n      return greeting + \"\\n\"\n        + \"\\n\"\n        + \"To verify your account email, simply click the link below.\\n\"\n        + \"\\n\"\n        + url + \"\\n\"\n        + \"\\n\"\n        + \"Thanks.\\n\";\n    }\n  },\n  enrollAccount: {\n    subject: function(user) {\n      return \"An account has been created for you on \" + Accounts.emailTemplates.siteName;\n    },\n    text: function(user, url) {\n      var greeting = (user.profile && user.profile.name) ?\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\n      return greeting + \"\\n\"\n        + \"\\n\"\n        + \"To start using the service, simply click the link below.\\n\"\n        + \"\\n\"\n        + url + \"\\n\"\n        + \"\\n\"\n        + \"Thanks.\\n\";\n    }\n  }\n};\n","/// BCRYPT\n\nvar bcrypt = NpmModuleBcrypt;\nvar bcryptHash = Meteor.wrapAsync(bcrypt.hash);\nvar bcryptCompare = Meteor.wrapAsync(bcrypt.compare);\n\n// User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords (unless they have a 'services.password.srp'\n// field, in which case they will be upgraded to bcrypt the next time\n// they log in).\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\n\nAccounts._bcryptRounds = 10;\n\n// Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\nvar getPasswordString = function (password) {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else { // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" +\n                      \"Only 'sha-256' is allowed.\");\n    }\n    password = password.digest;\n  }\n  return password;\n};\n\n// Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\nvar hashPassword = function (password) {\n  password = getPasswordString(password);\n  return bcryptHash(password, Accounts._bcryptRounds);\n};\n\n// Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\nAccounts._checkPassword = function (user, password) {\n  var result = {\n    userId: user._id\n  };\n\n  password = getPasswordString(password);\n\n  if (! bcryptCompare(password, user.services.password.bcrypt)) {\n    result.error = new Meteor.Error(403, \"Incorrect password\");\n  }\n\n  return result;\n};\nvar checkPassword = Accounts._checkPassword;\n\n///\n/// LOGIN\n///\n\n// Users can specify various keys to identify themselves with.\n// @param user {Object} with one of `id`, `username`, or `email`.\n// @returns A selector to pass to mongo to get the user record.\n\nvar selectorFromUserQuery = function (user) {\n  if (user.id)\n    return {_id: user.id};\n  else if (user.username)\n    return {username: user.username};\n  else if (user.email)\n    return {\"emails.address\": user.email};\n  throw new Error(\"shouldn't happen (validation missed something)\");\n};\n\nvar findUserFromUserQuery = function (user) {\n  var selector = selectorFromUserQuery(user);\n\n  var user = Meteor.users.findOne(selector);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  return user;\n};\n\n// XXX maybe this belongs in the check package\nvar NonEmptyString = Match.Where(function (x) {\n  check(x, String);\n  return x.length > 0;\n});\n\nvar userQueryValidator = Match.Where(function (user) {\n  check(user, {\n    id: Match.Optional(NonEmptyString),\n    username: Match.Optional(NonEmptyString),\n    email: Match.Optional(NonEmptyString)\n  });\n  if (_.keys(user).length !== 1)\n    throw new Match.Error(\"User property must have exactly one field\");\n  return true;\n});\n\nvar passwordValidator = Match.OneOf(\n  String,\n  { digest: String, algorithm: String }\n);\n\n// Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (! options.password || options.srp)\n    return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    password: passwordValidator\n  });\n\n\n  var user = findUserFromUserQuery(options.user);\n\n  if (!user.services || !user.services.password ||\n      !(user.services.password.bcrypt || user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  if (!user.services.password.bcrypt) {\n    if (typeof options.password === \"string\") {\n      // The client has presented a plaintext password, and the user is\n      // not upgraded to bcrypt yet. We don't attempt to tell the client\n      // to upgrade to bcrypt, because it might be a standalone DDP\n      // client doesn't know how to do such a thing.\n      var verifier = user.services.password.srp;\n      var newVerifier = SRP.generateVerifier(options.password, {\n        identity: verifier.identity, salt: verifier.salt});\n\n      if (verifier.verifier !== newVerifier.verifier) {\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Incorrect password\")\n        };\n      }\n\n      return {userId: user._id};\n    } else {\n      // Tell the client to use the SRP upgrade process.\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n        format: 'srp',\n        identity: user.services.password.srp.identity\n      }));\n    }\n  }\n\n  return checkPassword(\n    user,\n    options.password\n  );\n});\n\n// Handler to login using the SRP upgrade path. To use this login\n// handler, the client must provide:\n//   - srp: H(identity + \":\" + password)\n//   - password: a string or an object with properties 'digest' and 'algorithm'\n//\n// We use `options.srp` to verify that the client knows the correct\n// password without doing a full SRP flow. Once we've checked that, we\n// upgrade the user to bcrypt and remove the SRP information from the\n// user document.\n//\n// The client ends up using this login handler after trying the normal\n// login handler (above), which throws an error telling the client to\n// try the SRP upgrade path.\n//\n// XXX COMPAT WITH 0.8.1.3\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (!options.srp || !options.password)\n    return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    srp: String,\n    password: passwordValidator\n  });\n\n  var user = findUserFromUserQuery(options.user);\n\n  // Check to see if another simultaneous login has already upgraded\n  // the user record to bcrypt.\n  if (user.services && user.services.password && user.services.password.bcrypt)\n    return checkPassword(user, options.password);\n\n  if (!(user.services && user.services.password && user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  var v1 = user.services.password.srp.verifier;\n  var v2 = SRP.generateVerifier(\n    null,\n    {\n      hashedIdentityAndPassword: options.srp,\n      salt: user.services.password.srp.salt\n    }\n  ).verifier;\n  if (v1 !== v2)\n    return {\n      userId: user._id,\n      error: new Meteor.Error(403, \"Incorrect password\")\n    };\n\n  // Upgrade to bcrypt on successful login.\n  var salted = hashPassword(options.password);\n  Meteor.users.update(\n    user._id,\n    {\n      $unset: { 'services.password.srp': 1 },\n      $set: { 'services.password.bcrypt': salted }\n    }\n  );\n\n  return {userId: user._id};\n});\n\n\n///\n/// CHANGING\n///\n\n// Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\n//\n// XXX COMPAT WITH 0.8.1.3\n// Like the login method, if the user hasn't been upgraded from SRP to\n// bcrypt yet, then this method will throw an 'old password format'\n// error. The client should call the SRP upgrade login handler and then\n// retry this method again.\n//\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade\n// errors thrown. The reasoning for this is that clients using this\n// method directly will need to be updated anyway because we no longer\n// support the SRP flow that they would have been doing to use this\n// method previously.\nMeteor.methods({changePassword: function (oldPassword, newPassword) {\n  check(oldPassword, passwordValidator);\n  check(newPassword, passwordValidator);\n\n  if (!this.userId)\n    throw new Meteor.Error(401, \"Must be logged in\");\n\n  var user = Meteor.users.findOne(this.userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  if (!user.services || !user.services.password ||\n      (!user.services.password.bcrypt && !user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  if (! user.services.password.bcrypt) {\n    throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n      format: 'srp',\n      identity: user.services.password.srp.identity\n    }));\n  }\n\n  var result = checkPassword(user, oldPassword);\n  if (result.error)\n    throw result.error;\n\n  var hashed = hashPassword(newPassword);\n\n  // It would be better if this removed ALL existing tokens and replaced\n  // the token for the current connection with a new one, but that would\n  // be tricky, so we'll settle for just replacing all tokens other than\n  // the one for the current connection.\n  var currentToken = Accounts._getLoginToken(this.connection.id);\n  Meteor.users.update(\n    { _id: this.userId },\n    {\n      $set: { 'services.password.bcrypt': hashed },\n      $pull: {\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }\n      },\n      $unset: { 'services.password.reset': 1 }\n    }\n  );\n\n  return {passwordChanged: true};\n}});\n\n\n// Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n */\nAccounts.setPassword = function (userId, newPlaintextPassword, options) {\n  options = _.extend({logout: true}, options);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  var update = {\n    $unset: {\n      'services.password.srp': 1, // XXX COMPAT WITH 0.8.1.3\n      'services.password.reset': 1\n    },\n    $set: {'services.password.bcrypt': hashPassword(newPlaintextPassword)}\n  };\n\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n\n  Meteor.users.update({_id: user._id}, update);\n};\n\n\n///\n/// RESETTING VIA EMAIL\n///\n\n// Method called by a user to request a password reset email. This is\n// the start of the reset process.\nMeteor.methods({forgotPassword: function (options) {\n  check(options, {email: String});\n\n  var user = Meteor.users.findOne({\"emails.address\": options.email});\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  Accounts.sendResetPasswordEmail(user._id, options.email);\n}});\n\n// send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n */\nAccounts.sendResetPasswordEmail = function (userId, email) {\n  // Make sure the user exists, and email is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0])\n    email = user.emails[0].address;\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))\n    throw new Error(\"No such email for user.\");\n\n  var token = Random.secret();\n  var when = new Date();\n  var tokenRecord = {\n    token: token,\n    email: email,\n    when: when\n  };\n  Meteor.users.update(userId, {$set: {\n    \"services.password.reset\": tokenRecord\n  }});\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n\n  var resetPasswordUrl = Accounts.urls.resetPassword(token);\n\n  var options = {\n    to: email,\n    from: Accounts.emailTemplates.resetPassword.from\n      ? Accounts.emailTemplates.resetPassword.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.resetPassword.subject(user),\n    text: Accounts.emailTemplates.resetPassword.text(user, resetPasswordUrl)\n  };\n\n  if (typeof Accounts.emailTemplates.resetPassword.html === 'function')\n    options.html =\n      Accounts.emailTemplates.resetPassword.html(user, resetPasswordUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n// send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n */\nAccounts.sendEnrollmentEmail = function (userId, email) {\n  // XXX refactor! This is basically identical to sendResetPasswordEmail.\n\n  // Make sure the user exists, and email is in their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0])\n    email = user.emails[0].address;\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))\n    throw new Error(\"No such email for user.\");\n\n  var token = Random.secret();\n  var when = new Date();\n  var tokenRecord = {\n    token: token,\n    email: email,\n    when: when\n  };\n  Meteor.users.update(userId, {$set: {\n    \"services.password.reset\": tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n\n  var enrollAccountUrl = Accounts.urls.enrollAccount(token);\n\n  var options = {\n    to: email,\n    from: Accounts.emailTemplates.enrollAccount.from\n      ? Accounts.emailTemplates.enrollAccount.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.enrollAccount.subject(user),\n    text: Accounts.emailTemplates.enrollAccount.text(user, enrollAccountUrl)\n  };\n\n  if (typeof Accounts.emailTemplates.enrollAccount.html === 'function')\n    options.html =\n      Accounts.emailTemplates.enrollAccount.html(user, enrollAccountUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\nMeteor.methods({resetPassword: function (token, newPassword) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"resetPassword\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n      check(newPassword, passwordValidator);\n\n      var user = Meteor.users.findOne({\n        \"services.password.reset.token\": token});\n      if (!user)\n        throw new Meteor.Error(403, \"Token expired\");\n      var email = user.services.password.reset.email;\n      if (!_.include(_.pluck(user.emails || [], 'address'), email))\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Token has invalid email address\")\n        };\n\n      var hashed = hashPassword(newPassword);\n\n      // NOTE: We're about to invalidate tokens on the user, who we might be\n      // logged in as. Make sure to avoid logging ourselves out if this\n      // happens. But also make sure not to leave the connection in a state\n      // of having a bad token set if things fail.\n      var oldToken = Accounts._getLoginToken(self.connection.id);\n      Accounts._setLoginToken(user._id, self.connection, null);\n      var resetToOldToken = function () {\n        Accounts._setLoginToken(user._id, self.connection, oldToken);\n      };\n\n      try {\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        var affectedRecords = Meteor.users.update(\n          {\n            _id: user._id,\n            'emails.address': email,\n            'services.password.reset.token': token\n          },\n          {$set: {'services.password.bcrypt': hashed,\n                  'emails.$.verified': true},\n           $unset: {'services.password.reset': 1,\n                    'services.password.srp': 1}});\n        if (affectedRecords !== 1)\n          return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Invalid email\")\n          };\n      } catch (err) {\n        resetToOldToken();\n        throw err;\n      }\n\n      // Replace all valid login tokens with new ones (changing\n      // password should invalidate existing sessions).\n      Accounts._clearAllLoginTokens(user._id);\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n///\n/// EMAIL VERIFICATION\n///\n\n\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n */\nAccounts.sendVerificationEmail = function (userId, address) {\n  // XXX Also generate a link using which someone can delete this\n  // account if they own said address but weren't those who created\n  // this account.\n\n  // Make sure the user exists, and address is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first unverified address if we weren't passed an address.\n  if (!address) {\n    var email = _.find(user.emails || [],\n                       function (e) { return !e.verified; });\n    address = (email || {}).address;\n  }\n  // make sure we have a valid address\n  if (!address || !_.contains(_.pluck(user.emails || [], 'address'), address))\n    throw new Error(\"No such email address for user.\");\n\n\n  var tokenRecord = {\n    token: Random.secret(),\n    address: address,\n    when: new Date()};\n  Meteor.users.update(\n    {_id: userId},\n    {$push: {'services.email.verificationTokens': tokenRecord}});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'email');\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n  user.services.email.verificationTokens.push(tokenRecord);\n\n  var verifyEmailUrl = Accounts.urls.verifyEmail(tokenRecord.token);\n\n  var options = {\n    to: address,\n    from: Accounts.emailTemplates.verifyEmail.from\n      ? Accounts.emailTemplates.verifyEmail.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.verifyEmail.subject(user),\n    text: Accounts.emailTemplates.verifyEmail.text(user, verifyEmailUrl)\n  };\n\n  if (typeof Accounts.emailTemplates.verifyEmail.html === 'function')\n    options.html =\n      Accounts.emailTemplates.verifyEmail.html(user, verifyEmailUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n// Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\nMeteor.methods({verifyEmail: function (token) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"verifyEmail\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n\n      var user = Meteor.users.findOne(\n        {'services.email.verificationTokens.token': token});\n      if (!user)\n        throw new Meteor.Error(403, \"Verify email link expired\");\n\n      var tokenRecord = _.find(user.services.email.verificationTokens,\n                               function (t) {\n                                 return t.token == token;\n                               });\n      if (!tokenRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link expired\")\n        };\n\n      var emailsRecord = _.find(user.emails, function (e) {\n        return e.address == tokenRecord.address;\n      });\n      if (!emailsRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n        };\n\n      // By including the address in the query, we can use 'emails.$' in the\n      // modifier to get a reference to the specific object in the emails\n      // array. See\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n      Meteor.users.update(\n        {_id: user._id,\n         'emails.address': tokenRecord.address},\n        {$set: {'emails.$.verified': true},\n         $pull: {'services.email.verificationTokens': {token: token}}});\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n\n\n///\n/// CREATING USERS\n///\n\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\nvar createUser = function (options) {\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n  // options.\n  check(options, Match.ObjectIncluding({\n    username: Match.Optional(String),\n    email: Match.Optional(String),\n    password: Match.Optional(passwordValidator)\n  }));\n\n  var username = options.username;\n  var email = options.email;\n  if (!username && !email)\n    throw new Meteor.Error(400, \"Need to set a username or email\");\n\n  var user = {services: {}};\n  if (options.password) {\n    var hashed = hashPassword(options.password);\n    user.services.password = { bcrypt: hashed };\n  }\n\n  if (username)\n    user.username = username;\n  if (email)\n    user.emails = [{address: email, verified: false}];\n\n  return Accounts.insertUserDoc(options, user);\n};\n\n// method for create user. Requests come from the client.\nMeteor.methods({createUser: function (options) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"createUser\",\n    arguments,\n    \"password\",\n    function () {\n      // createUser() above does more checking.\n      check(options, Object);\n      if (Accounts._options.forbidClientAccountCreation)\n        return {\n          error: new Meteor.Error(403, \"Signups forbidden\")\n        };\n\n      // Create user. result contains id and token.\n      var userId = createUser(options);\n      // safety belt. createUser is supposed to throw on error. send 500 error\n      // instead of sending a verification email with empty userid.\n      if (! userId)\n        throw new Error(\"createUser failed to insert new user\");\n\n      // If `Accounts._options.sendVerificationEmail` is set, register\n      // a token to verify the user's primary email, and send it to\n      // that address.\n      if (options.email && Accounts._options.sendVerificationEmail)\n        Accounts.sendVerificationEmail(userId, options.email);\n\n      // client gets logged in as the new user afterwards.\n      return {userId: userId};\n    }\n  );\n}});\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\nAccounts.createUser = function (options, callback) {\n  options = _.clone(options);\n\n  // XXX allow an optional callback?\n  if (callback) {\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n  }\n\n  return createUser(options);\n};\n\n///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\nMeteor.users._ensureIndex('emails.validationTokens.token',\n                          {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('services.password.reset.token',\n                          {unique: 1, sparse: 1});\n"]}