{"version":3,"sources":["tomi:upload-server/upload_server.js","tomi:upload-server/router.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,2C;AACA,+B;AACA,6B;AACA,uC;AACA,6B;AACA,+B;AACA,2B;AACA,kC;;AAEA,mD;AACA,6C;;AAEA,e;AACA,oB;AACA,e;AACA,oB;AACA,kB;AACA,wB;AACA,gC;AACA,oC;AACA,iB;AACA,oC;AACA,yB;AACA,0E;AACA,2E;AACA,yC;AACA,oC;AACA,kB;AACA,kB;AACA,iB;AACA,iB;AACA,K;AACA,I;AACA,mB;AACA,+C;AACA,a;AACA,I;AACA,8C;AACA,yB;AACA,I;AACA,yB;AACA,I;AACA,gC;AACA,gB;AACA,I;AACA,6B;AACA,gB;AACA,I;AACA,kB;AACA,qB;AACA,0D;AACA,oE;AACA,I;AACA,c;AACA,wB;AACA,yB;AACA,wB;AACA,uB;AACA,uB;AACA,4B;AACA,sB;AACA,6B;AACA,gC;AACA,sF;AACA,2D;AACA,uB;AACA,G;AACA,sE;AACA,S;AACA,sE;AACA,sE;AACA,K;AACA,K;AACA,E;;;AAGA,gB;AACA,yB;AACA,0G;;AAEA,8B;AACA,0E;AACA,Y;AACA,mC;AACA,K;;AAEA,yB;AACA,yC;AACA,K;;AAEA,iC;AACA,uC;AACA,qD;AACA,O;AACA,K;;AAEA,sC;AACA,2C;AACA,K;;AAEA,iC;AACA,uE;AACA,Y;AACA,yC;AACA,K;;AAEA,yC;AACA,8C;AACA,K;;AAEA,yE;AACA,yE;AACA,yE;AACA,qF;AACA,sE;AACA,qF;AACA,4E;AACA,4E;AACA,yE;AACA,gE;;AAEA,2D;;AAEA,8E;AACA,oC;AACA,I;AACA,+B;;AAEA,kC;AACA,0D;AACA,I;AACA,8B;AACA,8D;AACA,kE;AACA,K;;AAEA,kB;AACA,oC;AACA,uC;AACA,M;AACA,kB;AACA,qC;AACA,wC;AACA,M;AACA,kB;AACA,qC;AACA,wC;AACA,M;AACA,oD;AACA,uB;AACA,8B;AACA,yC;AACA,mB;AACA,wD;AACA,a;AACA,a;AACA,oB;AACA,kC;AACA,6D;AACA,kC;AACA,oB;AACA,gB;AACA,gC;AACA,gD;AACA,qD;AACA,iD;AACA,e;AACA,0C;AACA,S;AACA,Q;AACA,uC;AACA,gC;AACA,iF;AACA,gB;AACA,8C;AACA,gF;AACA,mF;AACA,S;AACA,Q;AACA,0D;;;AAGA,2B;AACA,kD;AACA,gB;AACA,yD;AACA,uB;AACA,gB;AACA,a;AACA,K;;AAEA,yB;AACA,qB;AACA,kB;AACA,c;AACA,kB;AACA,iB;AACA,4B;;AAEA,8C;AACA,mE;AACA,kB;;AAEA,a;AACA,yE;AACA,qB;AACA,6D;AACA,uC;AACA,oB;AACA,iB;AACA,S;;AAEA,6B;AACA,mC;AACA,2F;AACA,0B;AACA,kD;AACA,W;AACA,yD;;AAEA,wD;AACA,yD;AACA,+B;;AAEA,yC;AACA,wC;AACA,6D;AACA,qC;AACA,oB;AACA,gB;AACA,6D;AACA,mD;AACA,oB;AACA,S;AACA,c;AACA,kB;AACA,wB;AACA,4B;AACA,uB;AACA,c;AACA,sB;AACA,4B;AACA,gB;AACA,c;AACA,6B;AACA,kB;AACA,K;AACA,G;AACA,C;;AAEA,iC;AACA,2C;AACA,E;;AAEA,yD;;AAEA,8C;AACA,qE;AACA,E;;AAEA,gC;AACA,wB;AACA,wB;AACA,wB;AACA,E;;AAEA,mD;AACA,iB;AACA,iB;AACA,2B;AACA,E;;AAEA,2C;AACA,oB;AACA,+D;AACA,qC;AACA,sE;AACA,mC;AACA,wD;AACA,wC;AACA,G;AACA,oB;AACA,E;;AAEA,2C;AACA,kE;AACA,2D;AACA,wC;AACA,4D;AACA,kE;AACA,G;AACA,E;;AAEA,oD;AACA,oB;AACA,oB;AACA,sE;AACA,oD;AACA,oD;AACA,oG;AACA,mE;AACA,sB;AACA,6D;AACA,Y;AACA,yD;AACA,sC;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,4C;AACA,qB;AACA,yC;AACA,kB;AACA,e;AACA,a;AACA,gB;AACA,a;AACA,0B;AACA,mB;AACA,qB;AACA,2C;AACA,+C;AACA,W;AACA,mD;AACA,O;AACA,M;AACA,kC;AACA,8C;AACA,6B;AACA,yD;AACA,wB;;AAEA,oB;AACA,2C;AACA,gB;AACA,yD;AACA,uB;AACA,gB;AACA,a;AACA,K;;AAEA,6C;AACA,yB;AACA,yC;AACA,8B;AACA,uB;AACA,K;AACA,mC;AACA,kC;AACA,2B;AACA,K;AACA,yD;AACA,kC;AACA,uC;AACA,iD;AACA,8B;;AAEA,oC;AACA,gB;AACA,oB;AACA,+B;AACA,4B;AACA,uC;AACA,a;AACA,K;;AAEA,2C;AACA,iE;AACA,oE;AACA,uC;AACA,0C;AACA,iD;AACA,2C;;AAEA,0C;AACA,oC;AACA,O;AACA,K;;AAEA,sC;AACA,qE;;AAEA,wB;AACA,gC;AACA,+C;;AAEA,gE;;AAEA,iD;AACA,qE;AACA,qB;AACA,kD;;AAEA,4C;AACA,4D;AACA,sD;AACA,S;;AAEA,4B;AACA,4B;AACA,8B;AACA,qD;AACA,oE;AACA,mB;AACA,S;AACA,K;;AAEA,6C;AACA,qC;AACA,uB;AACA,6C;AACA,a;;AAEA,gC;AACA,sC;AACA,sB;AACA,O;AACA,+B;AACA,yB;AACA,mB;AACA,6D;AACA,8C;AACA,uC;AACA,K;AACA,0C;AACA,E;;AAEA,+C;AACA,qB;AACA,a;AACA,iF;AACA,kE;AACA,8B;AACA,mE;AACA,uE;AACA,wE;AACA,W;AACA,yC;AACA,S;AACA,a;AACA,K;AACA,G;AACA,qC;AACA,E;;AAEA,qB;;AAEA,2C;AACA,a;AACA,W;AACA,G;;AAEA,gC;AACA,uB;;AAEA,6C;AACA,uB;AACA,e;AACA,K;;AAEA,oC;;AAEA,qC;AACA,+B;AACA,sD;AACA,K;AACA,G;AACA,C;;AAEA,iB;;AAEA,kD;AACA,kE;;;;;;;;;;;;;;;;;;;;AC1dA,uC;AACA,2B;AACA,4B;AACA,E;AACA,mC;AACA,E;AACA,iC;AACA,0B;;;AAGA,0B;AACA,0B;AACA,2B;AACA,sB;AACA,0B;AACA,wD;AACA,O;AACA,O;AACA,K","file":"/packages/tomi_upload-server.js","sourcesContent":["var formidable = Npm.require('formidable');\nvar http = Npm.require('http');\nvar sys = Npm.require('sys');\n//var connect = Npm.require('connect');\nvar url = Npm.require('url');\nvar path = Npm.require('path');\nvar fs = Npm.require('fs');\nvar Fiber = Npm.require('fibers');\n\nvar _existsSync = fs.existsSync || path.existsSync;\nvar imageMagick = Npm.require('imagemagick');\n\nvar options = {\n  /** @type String*/\n  tmpDir: null,\n  /** @type String*/\n  uploadDir: null,\n  uploadUrl: '/upload/',\n  checkCreateDirectories: false,\n  maxPostSize: 11000000000, // 11 GB\n  minFileSize: 1,\n  maxFileSize: 10000000000, // 10 GB\n  acceptFileTypes: /.+/i,\n  // Files not matched by this regular expression force a download dialog,\n  // to prevent executing any scripts in the context of the service domain:\n  inlineFileTypes: /\\.(gif|jpe?g|png)$/i,\n  imageTypes: /\\.(gif|jpe?g|png)$/i,\n  imageVersions: {\n    'thumbnail': {\n      width: 200,\n      height: 200\n    }\n  },\n  cacheTime: 86400,\n  getDirectory: function (fileInfo, formData) {\n    return \"\"\n  },\n  getFileName: function (fileInfo, formData) {\n    return fileInfo.name;\n  },\n  finished: function () {\n  },\n  validateRequest: function () {\n    return null;\n  },\n  validateFile: function () {\n    return null;\n  },\n  accessControl: {\n    allowOrigin: '*',\n    allowMethods: 'OPTIONS, HEAD, GET, POST, PUT, DELETE',\n    allowHeaders: 'Content-Type, Content-Range, Content-Disposition'\n  },\n  mimeTypes: {\n    \"html\": \"text/html\",\n    \"jpeg\": \"image/jpeg\",\n    \"jpg\": \"image/jpeg\",\n    \"png\": \"image/png\",\n    \"gif\": \"image/gif\",\n    \"js\": \"text/javascript\",\n    \"css\": \"text/css\",\n    \"pdf\": \"application/pdf\",\n    \"doc\": \"application/msword\",\n    \"docx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n    \"zip\": \"application/zip, application/x-compressed-zip\",\n    \"txt\": \"text/plain\"\n  }\n  /* Uncomment and edit this section to provide the service via HTTPS:\n   ssl: {\n   key: fs.readFileSync('/Applications/XAMPP/etc/ssl.key/server.key'),\n   cert: fs.readFileSync('/Applications/XAMPP/etc/ssl.crt/server.crt')\n   },\n   */\n};\n\n\nUploadServer = {\n  init: function (opts) {\n    if (opts.checkCreateDirectories != null) options.checkCreateDirectories = opts.checkCreateDirectories;\n\n    if (opts.tmpDir == null) {\n      throw new Meteor.Error('Temporary directory needs to be assigned!');\n    } else {\n      options.tmpDir = opts.tmpDir;\n    }\n\n    if (opts.cacheTime) {\n      options.cacheTime = opts.cacheTime;\n    }\n\n    if (opts.mimeTypes != null) {\n      for (var key in opts.mimeTypes) {\n        options.mimeTypes[key] = opts.mimeTypes[key];\n      }\n    }\n\n    if (opts.checkCreateDirectories) {\n      checkCreateDirectory(options.tmpDir);\n    }\n\n    if (opts.uploadDir == null) {\n      throw new Meteor.Error('Upload directory needs to be assigned!');\n    } else {\n      options.uploadDir = opts.uploadDir;\n    }\n\n    if (options.checkCreateDirectories) {\n      checkCreateDirectory(options.uploadDir);\n    }\n\n    if (opts.maxPostSize != null) options.maxPostSize = opts.maxPostSize;\n    if (opts.minFileSize != null) options.minFileSize = opts.maxPostSize;\n    if (opts.maxFileSize != null) options.maxFileSize = opts.maxFileSize;\n    if (opts.acceptFileTypes != null) options.acceptFileTypes = opts.acceptFileTypes;\n    if (opts.imageTypes != null) options.imageTypes = opts.imageTypes;\n    if (opts.validateRequest != null) options.validateRequest = opts.validateRequest;\n    if (opts.validateFile != null) options.validateFile = opts.validateFile;\n    if (opts.getDirectory != null) options.getDirectory = opts.getDirectory;\n    if (opts.getFileName != null) options.getFileName = opts.getFileName;\n    if (opts.finished != null) options.finished = opts.finished;\n\n    if (opts.uploadUrl) options.uploadUrl = opts.uploadUrl;\n\n    if (opts.imageVersions != null) options.imageVersions = opts.imageVersions\n    else options.imageVersions = [];\n  },\n  delete: function (filePath) {\n\n    // make sure paths are correct\n    fs.unlinkSync(path.join(options.uploadDir, filePath));\n  },\n  serve: function (req, res) {\n    if (options.tmpDir == null || options.uploadDir == null) {\n      throw new Meteor.Error('Upload component not initialised!');\n    }\n\n    res.setHeader(\n      'Access-Control-Allow-Origin',\n      options.accessControl.allowOrigin\n    );\n    res.setHeader(\n      'Access-Control-Allow-Methods',\n      options.accessControl.allowMethods\n    );\n    res.setHeader(\n      'Access-Control-Allow-Headers',\n      options.accessControl.allowHeaders\n    );\n    var handleResult = function (result, redirect) {\n        if (redirect) {\n          res.writeHead(302, {\n            'Location': redirect.replace(\n              /%s/,\n              encodeURIComponent(JSON.stringify(result))\n            )\n          });\n          res.end();\n        } else if (result.error) {\n          res.writeHead(403, {'Content-Type': 'text/plain'});\n          res.write(result.error);\n          res.end();\n        } else {\n          //res.writeHead(200, {\n          //  'Content-Type': req.headers.accept\n          //    .indexOf('application/json') !== -1 ?\n          //    'application/json' : 'text/plain'\n          //});\n          res.end(JSON.stringify(result));\n        }\n      },\n      setNoCacheHeaders = function () {\n        if (options.cacheTime) {\n          res.setHeader('Cache-Control', 'public, max-age=' + options.cacheTime);\n        } else {\n          res.setHeader('Pragma', 'no-cache');\n          res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate');\n          // res.setHeader('Content-Disposition', 'inline; filename=\"files.json\"');\n        }\n      },\n      handler = new UploadHandler(req, res, handleResult);\n\n\n    // validate the request\n    var error = options.validateRequest(req, res);\n    if (error) {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.write(error);\n      res.end();\n      return;\n    }\n\n    switch (req.method) {\n      case 'OPTIONS':\n        res.end();\n        break;\n      case 'HEAD':\n      case 'GET':\n        setNoCacheHeaders();\n\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(options.uploadDir, unescape(uri));\n        var stats;\n\n        try {\n          stats = fs.lstatSync(filename); // throws if path doesn't exist\n        } catch (e) {\n          res.writeHead(404, {'Content-Type': 'text/plain'});\n          res.write('404 Not Found\\n');\n          res.end();\n          return;\n        }\n\n        if (stats.isFile()) {\n          // path exists, is a file\n          var mimeType = options.mimeTypes[path.extname(filename).split(\".\").reverse()[0]];\n          if (!mimeType) {\n            mimeType = \"application/octet-stream\";\n          }\n          res.writeHead(200, {'Content-Type': mimeType});\n\n          //connect.static(options.uploadDir)(req, res);\n          var fileStream = fs.createReadStream(filename);\n          fileStream.pipe(res);\n\n        } else if (stats.isDirectory()) {\n          // path exists, is a directory\n          res.writeHead(403, {'Content-Type': 'text/plain'});\n          res.write('Access denied');\n          res.end();\n        } else {\n          res.writeHead(500, {'Content-Type': 'text/plain'});\n          res.write('500 Internal server error\\n');\n          res.end();\n        }\n        break;\n      case 'POST':\n        // validate post\n        setNoCacheHeaders();\n        handler.post();\n        break;\n      //case 'DELETE':\n      //  handler.destroy();\n      //  break;\n      default:\n        res.statusCode = 405;\n        res.end();\n    }\n  }\n}\n\nvar utf8encode = function (str) {\n  return unescape(encodeURIComponent(str));\n};\n\nvar nameCountRegexp = /(?:(?: \\(([\\d]+)\\))?(\\.[^.]+))?$/;\n\nvar nameCountFunc = function (s, index, ext) {\n  return ' (' + ((parseInt(index, 10) || 0) + 1) + ')' + (ext || '');\n};\n\nvar FileInfo = function (file) {\n  this.name = file.name;\n  this.size = file.size;\n  this.type = file.type;\n};\n\nvar UploadHandler = function (req, res, callback) {\n  this.req = req;\n  this.res = res;\n  this.callback = callback;\n};\n\nFileInfo.prototype.validate = function () {\n  this.error = null;\n  if (options.minFileSize && options.minFileSize > this.size) {\n    this.error = 'File is too small';\n  } else if (options.maxFileSize && options.maxFileSize < this.size) {\n    this.error = 'File is too big';\n  } else if (!options.acceptFileTypes.test(this.name)) {\n    this.error = 'Filetype not allowed';\n  }\n  return this.error;\n};\n\nFileInfo.prototype.safeName = function () {\n  // Prevent directory traversal and creating hidden system files:\n  this.name = path.basename(this.name).replace(/^\\.+/, '');\n  // Prevent overwriting existing files:\n  while (_existsSync(options.uploadDir + '/' + this.name)) {\n    this.name = this.name.replace(nameCountRegexp, nameCountFunc);\n  }\n};\n\nFileInfo.prototype.initUrls = function (req, form) {\n  if (!this.error) {\n    var that = this,\n      subDirectory = options.getDirectory(this.name, form.formFields),\n      baseUrl = (options.ssl ? 'https:' : 'http:') +\n        '//' + req.headers.host + options.uploadUrl;\n    this.url = baseUrl + (subDirectory ? (subDirectory + '/') : '') + encodeURIComponent(this.name);\n    Object.keys(options.imageVersions).forEach(function (version) {\n      if (_existsSync(\n          options.uploadDir + '/' + version + '/' + that.name\n        )) {\n        that[version + 'Url'] = baseUrl + version + '/' +\n        encodeURIComponent(that.name);\n      }\n    });\n  }\n};\n\nUploadHandler.prototype.post = function () {\n  var handler = this,\n    form = new formidable.IncomingForm(),\n    tmpFiles = [],\n    files = [],\n    map = {},\n    counter = 1,\n    redirect,\n    finish = function () {\n      counter -= 1;\n      if (!counter) {\n        files.forEach(function (fileInfo) {\n          fileInfo.initUrls(handler.req, form);\n        });\n        handler.callback({files: files}, redirect);\n      }\n    };\n  form.uploadDir = options.tmpDir;\n  form.on('fileBegin', function (name, file) {\n    tmpFiles.push(file.path);\n    var fileInfo = new FileInfo(file, handler.req, true);\n    fileInfo.safeName();\n\n    // validate post\n    var error = options.validateFile(file);\n    if (error) {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.write(error);\n      res.end();\n      return;\n    }\n\n    map[path.basename(file.path)] = fileInfo;\n    files.push(fileInfo);\n  }).on('field', function (name, value) {\n    if (name === 'redirect') {\n      redirect = value;\n    }\n    // remember all the form fields\n    if (this.formFields == null) {\n      this.formFields = {};\n    }\n    //  console.log('Form field: ' + name + \"-\" + value);\n    this.formFields[name] = value;\n  }).on('file', function (name, file) {\n    var fileInfo = map[path.basename(file.path)];\n    fileInfo.size = file.size;\n\n    var error = fileInfo.validate();\n    if (error) {\n      // delete file\n      fs.unlinkSync(file.path);\n      // callback with error\n      handler.callback({error: error});\n      return;\n    }\n\n    // we can store files in subdirectories\n    var folder = options.getDirectory(fileInfo, this.formFields);\n    // check if directory exists, if not, create all the directories\n    var subFolders = folder.split('/');\n    var currentFolder = options.uploadDir;\n    for (var i = 0; i < subFolders.length; i++) {\n      currentFolder += '/' + subFolders[i];\n\n      if (!fs.existsSync(currentFolder)) {\n        fs.mkdirSync(currentFolder);\n      }\n    }\n\n    // possibly rename file if needed;\n    var newFileName = options.getFileName(fileInfo, this.formFields);\n\n    // set the file name\n    fileInfo.name = newFileName;\n    fileInfo.path = folder + \"/\" + newFileName;\n\n    fs.renameSync(file.path, currentFolder + \"/\" + newFileName);\n\n    if (options.imageTypes.test(fileInfo.name)) {\n      Object.keys(options.imageVersions).forEach(function (version) {\n        counter += 1;\n        var opts = options.imageVersions[version];\n\n        // check if version directory exists\n        if (!fs.existsSync(currentFolder + '/' + version)) {\n          fs.mkdirSync(currentFolder + '/' + version);\n        }\n\n        imageMagick.resize({\n          width: opts.width,\n          height: opts.height,\n          srcPath: currentFolder + '/' + newFileName,\n          dstPath: currentFolder + '/' + version + '/' + newFileName\n        }, finish);\n      });\n    }\n\n    // call the feedback within its own fiber\n    var formFields = this.formFields;\n    Fiber(function () {\n      options.finished(fileInfo, formFields);\n    }).run();\n\n  }).on('aborted', function () {\n    tmpFiles.forEach(function (file) {\n      fs.unlink(file);\n    });\n  }).on('error', function (e) {\n    console.log('ERROR');\n    console.log(e);\n  }).on('progress', function (bytesReceived, bytesExpected) {\n    if (bytesReceived > options.maxPostSize) {\n      handler.req.connection.destroy();\n    }\n  }).on('end', finish).parse(handler.req);\n};\n\nUploadHandler.prototype.destroy = function () {\n  var handler = this,\n    fileName;\n  if (handler.req.url.slice(0, options.uploadUrl.length) === options.uploadUrl) {\n    fileName = path.basename(decodeURIComponent(handler.req.url));\n    if (fileName[0] !== '.') {\n      fs.unlink(options.uploadDir + '/' + fileName, function (ex) {\n        Object.keys(options.imageVersions).forEach(function (version) {\n          fs.unlink(options.uploadDir + '/' + version + '/' + fileName);\n        });\n        handler.callback({success: !ex});\n      });\n      return;\n    }\n  }\n  handler.callback({success: false});\n};\n\n// create directories\n\nvar checkCreateDirectory = function (dir) {\n  if (!dir) {\n    return;\n  }\n\n  var dirParts = dir.split('/');\n  var currentDir = '/';\n\n  for (var i = 0; i < dirParts.length; i++) {\n    if (!dirParts[i]) {\n      continue;\n    }\n\n    currentDir += dirParts[i] + '/';\n\n    if (!fs.existsSync(currentDir)) {\n      fs.mkdirSync(currentDir);\n      console.log('Created directory: ' + currentDir);\n    }\n  }\n}\n\n// declare routes\n\nRoutePolicy.declare(options.uploadUrl, 'network');\nWebApp.connectHandlers.use(options.uploadUrl, UploadServer.serve);\n\n","//Router.route('/upload', function () {\n//  var req = this.request;\n//  var res = this.response;\n//\n//  console.log('doing something');\n//\n//  UploadServer.serve(req, res);\n//}, { where: 'server' });\n\n\n//Router.map(function () {\n//  this.route('upload', {\n//    path: '/upload/(.*)',\n//    where: 'server',\n//    action: function() {\n//      UploadServer.serve(this.request, this.response);\n//    }\n//  });\n//});"]}