{"version":3,"file":"/packages/alanning:roles.js","sources":["alanning:roles/roles_server.js","alanning:roles/roles_common.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,e;;;AAGA,G;AACA,oE;AACA,sC;AACA,G;AACA,oB;AACA,+C;;AAEA,gD;AACA,gD;AACA,C;;;AAGA,G;AACA,uD;AACA,mB;AACA,G;AACA,kC;AACA,2B;AACA,wB;;AAEA,0D;AACA,E;;AAEA,K;;;;;;;;;;;;;;;;;;;AC1BA,e;;AAEA,G;AACA,uG;AACA,E;AACA,gB;AACA,G;;AAEA,G;AACA,oE;AACA,sC;AACA,G;AACA,oB;AACA,+C;AACA,C;;AAEA,G;AACA,6E;AACA,E;AACA,qE;AACA,E;AACA,e;AACA,e;AACA,G;AACA,mC;AACA,Y;AACA,C;;AAEA,a;;AAEA,0G;;AAEA,iB;;AAEA,K;AACA,gE;AACA,gE;AACA,I;AACA,a;AACA,iE;AACA,qD;AACA,I;AACA,sE;AACA,6D;AACA,sD;AACA,I;AACA,2B;AACA,iB;AACA,Y;AACA,W;AACA,K;AACA,mC;;;AAGA,K;AACA,mD;AACA,I;AACA,uB;AACA,sC;AACA,oC;AACA,K;AACA,+B;AACA,W;AACA,a;;AAEA,a;AACA,mC;AACA,sC;AACA,Y;AACA,K;;AAEA,S;AACA,qD;AACA,e;AACA,iB;AACA,gE;AACA,wC;AACA,2E;AACA,0C;AACA,uE;AACA,yB;AACA,2C;AACA,2D;AACA,a;AACA,K;AACA,I;;AAEA,K;AACA,0E;AACA,+C;AACA,I;AACA,uB;AACA,sC;AACA,K;AACA,+B;AACA,qB;;AAEA,iD;AACA,qD;AACA,iD;;AAEA,4B;AACA,gD;AACA,K;;AAEA,qD;AACA,mB;AACA,8C;AACA,K;AACA,I;;AAEA,K;AACA,qD;AACA,I;AACA,iE;AACA,oD;AACA,I;AACA,+B;AACA,4C;AACA,4B;AACA,I;AACA,a;AACA,+C;AACA,uE;AACA,iE;AACA,mG;AACA,mE;AACA,I;AACA,4B;AACA,0E;AACA,6E;AACA,4E;AACA,sD;AACA,2E;AACA,6E;AACA,4C;AACA,2E;AACA,iF;AACA,8E;AACA,4E;AACA,8D;AACA,K;AACA,mD;AACA,gD;AACA,2E;AACA,I;;AAEA,K;AACA,mC;AACA,I;AACA,a;AACA,4C;AACA,oE;AACA,8D;AACA,gG;AACA,gE;AACA,I;AACA,yB;AACA,0E;AACA,6E;AACA,4E;AACA,sD;AACA,gE;AACA,6E;AACA,4C;AACA,2E;AACA,iF;AACA,8E;AACA,4E;AACA,8D;AACA,K;AACA,gD;AACA,gD;AACA,sE;AACA,I;;AAEA,K;AACA,4B;AACA,I;AACA,a;AACA,uD;AACA,uE;AACA,+E;AACA,kE;AACA,I;AACA,iC;AACA,0E;AACA,iE;AACA,yE;AACA,2D;AACA,K;AACA,wD;AACA,c;;AAEA,yD;AACA,yD;AACA,gB;AACA,oC;AACA,0F;AACA,2B;AACA,sE;;AAEA,2C;AACA,uC;AACA,K;;AAEA,oB;AACA,0C;AACA,0C;;AAEA,2C;AACA,mD;AACA,a;AACA,qC;AACA,uB;AACA,4C;AACA,sB;AACA,sC;AACA,wB;AACA,S;AACA,O;AACA,iB;AACA,U;;AAEA,8C;AACA,I;AACA,gB;AACA,6B;AACA,6C;AACA,Y;AACA,yC;AACA,K;;AAEA,S;AACA,4B;AACA,gF;AACA,uC;AACA,iD;AACA,U;AACA,c;AACA,+E;AACA,qE;AACA,O;AACA,K;AACA,gB;AACA,iG;;AAEA,qC;AACA,wD;AACA,wD;AACA,O;;AAEA,c;AACA,K;AACA,I;;AAEA,K;AACA,kD;AACA,I;AACA,a;AACA,2B;AACA,0C;AACA,qD;AACA,4C;AACA,uD;AACA,I;AACA,2B;AACA,iE;AACA,iE;AACA,2E;AACA,I;AACA,6E;AACA,0C;AACA,Q;AACA,yB;AACA,8D;AACA,qE;AACA,+E;AACA,0E;AACA,gF;AACA,gD;AACA,iF;AACA,iE;AACA,mE;AACA,K;AACA,+C;AACA,W;AACA,kB;AACA,c;AACA,mB;AACA,qB;;AAEA,oC;AACA,4B;AACA,qB;AACA,K;;AAEA,2B;AACA,gB;AACA,iD;AACA,wC;;AAEA,2C;AACA,uC;AACA,K;AACA,I;AACA,mC;AACA,4B;AACA,iC;AACA,8C;AACA,4C;AACA,U;AACA,iD;AACA,8C;AACA,8E;AACA,mD;AACA,U;AACA,qB;AACA,iE;AACA,mD;AACA,6F;AACA,kE;AACA,Y;AACA,S;AACA,oB;AACA,O;;AAEA,qD;AACA,mB;AACA,0C;AACA,e;AACA,K;;AAEA,yB;;;AAGA,8B;;AAEA,sC;AACA,mB;AACA,0D;AACA,8B;;AAEA,gB;AACA,+E;AACA,qB;AACA,kB;AACA,gD;AACA,yD;AACA,c;AACA,qB;AACA,+C;AACA,gC;AACA,Y;AACA,iE;AACA,4B;AACA,qB;AACA,kB;AACA,wC;AACA,0D;AACA,c;AACA,2C;AACA,K;;AAEA,2D;AACA,+B;AACA,I;;AAEA,K;AACA,yB;AACA,I;AACA,4B;AACA,8D;AACA,yE;AACA,6E;AACA,qD;AACA,K;AACA,2C;AACA,wB;AACA,gB;AACA,8C;AACA,qC;;AAEA,2C;AACA,uC;AACA,K;;AAEA,mC;AACA,kC;AACA,2B;AACA,oC;;AAEA,0C;AACA,4B;AACA,e;AACA,K;;AAEA,uC;;AAEA,gB;AACA,mF;AACA,K;;AAEA,8B;AACA,uB;;AAEA,2E;AACA,+C;AACA,I;;AAEA,K;AACA,uC;AACA,I;AACA,wB;AACA,8C;AACA,K;AACA,4B;AACA,mD;AACA,I;;AAEA,K;AACA,iD;AACA,I;AACA,yE;AACA,gF;AACA,+E;AACA,wB;AACA,I;AACA,2B;AACA,0E;AACA,4E;AACA,wE;AACA,yE;AACA,4E;AACA,6C;AACA,K;AACA,0C;AACA,c;AACA,qB;AACA,kB;;AAEA,2C;AACA,0C;AACA,I;AACA,gB;AACA,oC;AACA,0F;AACA,2B;AACA,sE;;AAEA,2C;AACA,uC;AACA,K;;AAEA,qB;;AAEA,sC;AACA,mB;AACA,0D;AACA,8B;;AAEA,gB;AACA,+E;AACA,Y;AACA,kB;AACA,gD;AACA,yD;AACA,c;AACA,qB;AACA,+C;AACA,gC;AACA,Y;AACA,iE;AACA,4B;AACA,Y;AACA,kB;AACA,wC;AACA,0D;AACA,c;AACA,2C;AACA,K;;AAEA,mC;AACA,4B;AACA,E;AACA,K;AACA,kC;AACA,I;AACA,6B;AACA,8D;AACA,yE;AACA,I;AACA,yF;AACA,K;AACA,2C;AACA,wB;AACA,I;AACA,wB;AACA,e;AACA,6C;AACA,oC;;AAEA,2C;AACA,mC;AACA,K;;AAEA,mC;AACA,kC;AACA,2B;AACA,oC;AACA,I;AACA,yC;AACA,4B;AACA,e;AACA,K;;AAEA,8C;AACA,gE;;AAEA,e;AACA,0D;AACA,+E;AACA,qC;AACA,S;AACA,S;AACA,wB;AACA,W;AACA,+D;AACA,K;;AAEA,2B;;;AAGA,K;AACA,6E;AACA,6C;AACA,I;AACA,6B;AACA,e;AACA,yB;AACA,4B;AACA,qE;AACA,K;AACA,6C;AACA,mB;;AAEA,gB;AACA,yC;AACA,sB;AACA,2C;AACA,Y;AACA,qC;AACA,kC;AACA,K;;AAEA,iB;AACA,6B;;AAEA,K;AACA,4E;AACA,oD;AACA,I;AACA,mC;AACA,e;AACA,yB;AACA,4B;AACA,qE;AACA,K;AACA,iD;AACA,mB;;AAEA,gB;AACA,yC;AACA,2B;AACA,yD;AACA,Y;AACA,qC;AACA,gD;AACA,K;;AAEA,iB;AACA,kC;;;AAGA,K;AACA,6E;AACA,e;AACA,I;AACA,6B;AACA,e;AACA,0E;AACA,6E;AACA,8E;AACA,sD;AACA,gE;AACA,6E;AACA,4C;AACA,2E;AACA,iF;AACA,8E;AACA,4E;AACA,8D;AACA,6E;AACA,qD;AACA,2B;AACA,8B;AACA,K;AACA,mE;AACA,yD;AACA,yD;AACA,gB;AACA,oC;AACA,0F;AACA,2B;AACA,sE;;AAEA,2C;AACA,uC;AACA,K;;AAEA,sB;AACA,c;AACA,c;;AAEA,qC;AACA,0C;AACA,0C;;AAEA,2B;AACA,mD;AACA,c;AACA,qC;AACA,sC;AACA,8B;AACA,O;AACA,iB;AACA,U;;AAEA,iF;AACA,oC;;AAEA,mD;AACA,mF;AACA,4B;AACA,iB;AACA,U;AACA,mC;AACA,iC;AACA,8B;AACA,O;AACA,M;;AAEA,2C;AACA,mD;AACA,a;AACA,qC;AACA,uB;AACA,4C;AACA,sB;AACA,sC;AACA,wB;AACA,S;AACA,O;AACA,iB;AACA,U;AACA,I;AACA,uB;AACA,wC;AACA,I;AACA,S;AACA,4B;AACA,iE;AACA,qC;AACA,uC;AACA,kD;AACA,U;AACA,c;AACA,+D;AACA,6B;AACA,4B;AACA,8B;AACA,iB;AACA,wB;AACA,O;AACA,K;AACA,gB;AACA,wF;AACA,oF;;AAEA,qC;AACA,qD;AACA,mE;AACA,wD;AACA,O;;AAEA,c;AACA,K;AACA,4B;;AAEA,8B;;AAEA,K","sourcesContent":[";(function () {\n\n\n/**\n * Roles collection documents consist only of an id and a role name.\n *   ex: { _id:<uuid>, name: \"admin\" }\n */\nif (!Meteor.roles) {\n  Meteor.roles = new Meteor.Collection(\"roles\")\n\n  // Create default indexes for roles collection\n  Meteor.roles._ensureIndex('name', {unique: 1})\n}\n\n\n/**\n * Always publish logged-in user's roles so client-side\n * checks can work.\n */\nMeteor.publish(null, function () {\n  var userId = this.userId,\n      fields = {roles:1}\n\n  return Meteor.users.find({_id:userId}, {fields: fields})\n})\n\n}());\n",";(function () {\n\n/**\n * Provides functions related to user authorization. Compatible with built-in Meteor accounts packages.\n *\n * @module Roles\n */\n\n/**\n * Roles collection documents consist only of an id and a role name.\n *   ex: { _id:<uuid>, name: \"admin\" }\n */\nif (!Meteor.roles) {\n  Meteor.roles = new Meteor.Collection(\"roles\")\n}\n\n/**\n * Role-based authorization compatible with built-in Meteor accounts package.\n *\n * Stores user's current roles in a 'roles' field on the user object.\n *\n * @class Roles\n * @constructor\n */\nif ('undefined' === typeof Roles) {\n  Roles = {}\n}\n\n\"use strict\";\n\nvar mixingGroupAndNonGroupErrorMsg = \"Roles error: Can't mix grouped and non-grouped roles for same user\";\n\n_.extend(Roles, {\n\n  /**\n   * Constant used to reference the special 'global' group that \n   * can be used to apply blanket permissions across all groups.\n   *\n   * @example\n   *     Roles.addUsersToRoles(user, 'admin', Roles.GLOBAL_GROUP)\n   *     Roles.userIsInRole(user, 'admin') // => true\n   *\n   *     Roles.setUserRoles(user, 'support-staff', Roles.GLOBAL_GROUP)\n   *     Roles.userIsInRole(user, 'support-staff') // => true\n   *     Roles.userIsInRole(user, 'admin') // => false\n   *\n   * @property GLOBAL_GROUP\n   * @type String\n   * @static\n   * @final\n   */\n  GLOBAL_GROUP: '__global_roles__',\n\n\n  /**\n   * Create a new role. Whitespace will be trimmed.\n   *\n   * @method createRole\n   * @param {String} role Name of role\n   * @return {String} id of new role\n   */\n  createRole: function (role) {\n    var id,\n        match\n\n    if (!role\n        || 'string' !== typeof role\n        || role.trim().length === 0) {\n      return\n    }\n\n    try {\n      id = Meteor.roles.insert({'name': role.trim()})\n      return id\n    } catch (e) {\n      // (from Meteor accounts-base package, insertUserDoc func)\n      // XXX string parsing sucks, maybe\n      // https://jira.mongodb.org/browse/SERVER-3069 will get fixed one day\n      if (e.name !== 'MongoError') throw e\n      match = e.err.match(/^E11000 duplicate key error index: ([^ ]+)/)\n      if (!match) throw e\n      if (match[1].indexOf('$name') !== -1)\n        throw new Meteor.Error(403, \"Role already exists.\")\n      throw e\n    }\n  },\n\n  /**\n   * Delete an existing role.  Will throw \"Role in use\" error if any users\n   * are currently assigned to the target role.\n   *\n   * @method deleteRole\n   * @param {String} role Name of role\n   */\n  deleteRole: function (role) {\n    if (!role) return\n\n    var foundExistingUser = Meteor.users.findOne(\n                              {roles: {$in: [role]}},\n                              {fields: {_id: 1}})\n\n    if (foundExistingUser) {\n      throw new Meteor.Error(403, 'Role in use')\n    }\n\n    var thisRole = Meteor.roles.findOne({name: role})\n    if (thisRole) {\n      Meteor.roles.remove({_id: thisRole._id})\n    }\n  },\n\n  /**\n   * Add users to roles. Will create roles as needed.\n   *\n   * NOTE: Mixing grouped and non-grouped roles for the same user\n   *       is not supported and will throw an error.\n   *\n   * Makes 2 calls to database:\n   *  1. retrieve list of all existing roles\n   *  2. update users' roles\n   *\n   * @example\n   *     Roles.addUsersToRoles(userId, 'admin')\n   *     Roles.addUsersToRoles(userId, ['view-secrets'], 'example.com')\n   *     Roles.addUsersToRoles([user1, user2], ['user','editor'])\n   *     Roles.addUsersToRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *     Roles.addUsersToRoles(userId, 'admin', Roles.GLOBAL_GROUP)\n   *\n   * @method addUsersToRoles\n   * @param {Array|String} users User id(s) or object(s) with an _id field\n   * @param {Array|String} roles Name(s) of roles/permissions to add users to\n   * @param {String} [group] Optional group name. If supplied, roles will be\n   *                         specific to that group.  \n   *                         Group names can not start with '$' or numbers.\n   *                         Periods in names '.' are automatically converted\n   *                         to underscores.\n   *                         The special group Roles.GLOBAL_GROUP provides \n   *                         a convenient way to assign blanket roles/permissions\n   *                         across all groups.  The roles/permissions in the \n   *                         Roles.GLOBAL_GROUP group will be automatically \n   *                         included in checks for any group.\n   */\n  addUsersToRoles: function (users, roles, group) {\n    // use Template pattern to update user roles\n    Roles._updateUserRoles(users, roles, group, Roles._update_$addToSet_fn)\n  },\n\n  /**\n   * Set a users roles/permissions.\n   *\n   * @example\n   *     Roles.setUserRoles(userId, 'admin')\n   *     Roles.setUserRoles(userId, ['view-secrets'], 'example.com')\n   *     Roles.setUserRoles([user1, user2], ['user','editor'])\n   *     Roles.setUserRoles([user1, user2], ['glorious-admin', 'perform-action'], 'example.org')\n   *     Roles.setUserRoles(userId, 'admin', Roles.GLOBAL_GROUP)\n   *\n   * @method setUserRoles\n   * @param {Array|String} users User id(s) or object(s) with an _id field\n   * @param {Array|String} roles Name(s) of roles/permissions to add users to\n   * @param {String} [group] Optional group name. If supplied, roles will be\n   *                         specific to that group.  \n   *                         Group names can not start with '$'.\n   *                         Periods in names '.' are automatically converted\n   *                         to underscores.\n   *                         The special group Roles.GLOBAL_GROUP provides \n   *                         a convenient way to assign blanket roles/permissions\n   *                         across all groups.  The roles/permissions in the \n   *                         Roles.GLOBAL_GROUP group will be automatically \n   *                         included in checks for any group.\n   */\n  setUserRoles: function (users, roles, group) {\n    // use Template pattern to update user roles\n    Roles._updateUserRoles(users, roles, group, Roles._update_$set_fn)\n  },\n\n  /**\n   * Remove users from roles\n   *\n   * @example\n   *     Roles.removeUsersFromRoles(users.bob, 'admin')\n   *     Roles.removeUsersFromRoles([users.bob, users.joe], ['editor'])\n   *     Roles.removeUsersFromRoles([users.bob, users.joe], ['editor', 'user'])\n   *     Roles.removeUsersFromRoles(users.eve, ['user'], 'group1')\n   *\n   * @method removeUsersFromRoles\n   * @param {Array|String} users User id(s) or object(s) with an _id field\n   * @param {Array|String} roles Name(s) of roles to add users to\n   * @param {String} [group] Optional. Group name. If supplied, only that\n   *                         group will have roles removed.\n   */\n  removeUsersFromRoles: function (users, roles, group) {\n    var update\n\n    if (!users) throw new Error (\"Missing 'users' param\")\n    if (!roles) throw new Error (\"Missing 'roles' param\")\n    if (group) {\n      if ('string' !== typeof group)\n        throw new Error (\"Roles error: Invalid parameter 'group'. Expected 'string' type\")\n      if ('$' === group[0])\n        throw new Error (\"Roles error: groups can not start with '$'\")\n\n      // convert any periods to underscores\n      group = group.replace(/\\./g, '_')\n    }\n\n    // ensure arrays\n    if (!_.isArray(users)) users = [users]\n    if (!_.isArray(roles)) roles = [roles]\n\n    // ensure users is an array of user ids\n    users = _.reduce(users, function (memo, user) {\n      var _id\n      if ('string' === typeof user) {\n        memo.push(user)\n      } else if ('object' === typeof user) {\n        _id = user._id\n        if ('string' === typeof _id) {\n          memo.push(_id)\n        }\n      }\n      return memo\n    }, [])\n\n    // update all users, remove from roles set\n    \n    if (group) {\n      update = {$pullAll: {}}\n      update.$pullAll['roles.'+group] = roles\n    } else {\n      update = {$pullAll: {roles: roles}}\n    }\n\n    try {\n      if (Meteor.isClient) {\n        // Iterate over each user to fulfill Meteor's 'one update per ID' policy\n        _.each(users, function (user) {\n          Meteor.users.update({_id:user}, update)\n        })\n      } else {\n        // On the server we can leverage MongoDB's $in operator for performance\n        Meteor.users.update({_id:{$in:users}}, update, {multi: true})\n      }\n    }\n    catch (ex) {\n      var removeNonGroupedRoleFromGroupMsg = 'Cannot apply $pull/$pullAll modifier to non-array' \n\n      if (ex.name === 'MongoError' &&\n          ex.err === removeNonGroupedRoleFromGroupMsg) {\n        throw new Error (mixingGroupAndNonGroupErrorMsg)\n      }\n\n      throw ex\n    }\n  },\n\n  /**\n   * Check if user has specified permissions/roles\n   *\n   * @example\n   *     // non-group usage\n   *     Roles.userIsInRole(user, 'admin')\n   *     Roles.userIsInRole(user, ['admin','editor'])\n   *     Roles.userIsInRole(userId, 'admin')\n   *     Roles.userIsInRole(userId, ['admin','editor'])\n   *\n   *     // per-group usage\n   *     Roles.userIsInRole(user,   ['admin','editor'], 'group1')\n   *     Roles.userIsInRole(userId, ['admin','editor'], 'group1')\n   *     Roles.userIsInRole(userId, ['admin','editor'], Roles.GLOBAL_GROUP)\n   *\n   *     // this format can also be used as short-hand for Roles.GLOBAL_GROUP\n   *     Roles.userIsInRole(user, 'admin')\n   *    \n   * @method userIsInRole\n   * @param {String|Object} user User Id or actual user object\n   * @param {String|Array} roles Name of role/permission or Array of \n   *                            roles/permissions to check against.  If array, \n   *                            will return true if user is in _any_ role.\n   * @param {String} [group] Optional. Name of group.  If supplied, limits check\n   *                         to just that group.\n   *                         The user's Roles.GLOBAL_GROUP will always be checked\n   *                         whether group is specified or not.  \n   * @return {Boolean} true if user is in _any_ of the target roles\n   */\n  userIsInRole: function (user, roles, group) {\n    var id,\n        userRoles,\n        query,\n        groupQuery,\n        found = false\n\n    // ensure array to simplify code\n    if (!_.isArray(roles)) {\n      roles = [roles]\n    }\n\n    if (!user) return false\n    if (group) {\n      if ('string' !== typeof group) return false\n      if ('$' === group[0]) return false\n\n      // convert any periods to underscores\n      group = group.replace(/\\./g, '_')\n    }\n    \n    if ('object' === typeof user) {\n      userRoles = user.roles\n      if (_.isArray(userRoles)) {\n        return _.some(roles, function (role) {\n          return _.contains(userRoles, role)\n        })\n      } else if ('object' === typeof userRoles) {\n        // roles field is dictionary of groups\n        found = _.isArray(userRoles[group]) && _.some(roles, function (role) {\n          return _.contains(userRoles[group], role)\n        })\n        if (!found) {\n          // not found in regular group or group not specified.  \n          // check Roles.GLOBAL_GROUP, if it exists\n          found = _.isArray(userRoles[Roles.GLOBAL_GROUP]) && _.some(roles, function (role) {\n            return _.contains(userRoles[Roles.GLOBAL_GROUP], role)\n          })\n        }\n        return found\n      }\n\n      // missing roles field, try going direct via id\n      id = user._id\n    } else if ('string' === typeof user) {\n      id = user\n    }\n\n    if (!id) return false\n\n\n    query = {_id: id, $or: []}\n\n    // always check Roles.GLOBAL_GROUP\n    groupQuery = {}\n    groupQuery['roles.'+Roles.GLOBAL_GROUP] = {$in: roles}\n    query.$or.push(groupQuery)\n\n    if (group) {\n      // structure of query, when group specified including Roles.GLOBAL_GROUP \n      //   {_id: id, \n      //    $or: [\n      //      {'roles.group1':{$in: ['admin']}},\n      //      {'roles.__global_roles__':{$in: ['admin']}}\n      //    ]}\n      groupQuery = {}\n      groupQuery['roles.'+group] = {$in: roles}\n      query.$or.push(groupQuery)\n    } else {\n      // structure of query, where group not specified. includes \n      // Roles.GLOBAL_GROUP \n      //   {_id: id, \n      //    $or: [\n      //      {roles: {$in: ['admin']}},\n      //      {'roles.__global_roles__': {$in: ['admin']}}\n      //    ]}\n      query.$or.push({roles: {$in: roles}})\n    }\n\n    found = Meteor.users.findOne(query, {fields: {_id: 1}})\n    return found ? true : false\n  },\n\n  /**\n   * Retrieve users roles\n   *\n   * @method getRolesForUser\n   * @param {String|Object} user User Id or actual user object\n   * @param {String} [group] Optional name of group to restrict roles to.\n   *                         User's Roles.GLOBAL_GROUP will also be included.\n   * @return {Array} Array of user's roles, unsorted.\n   */\n  getRolesForUser: function (user, group) {\n    if (!user) return []\n    if (group) {\n      if ('string' !== typeof group) return []\n      if ('$' === group[0]) return []\n\n      // convert any periods to underscores\n      group = group.replace(/\\./g, '_')\n    }\n\n    if ('string' === typeof user) {\n      user = Meteor.users.findOne(\n               {_id: user},\n               {fields: {roles: 1}})\n\n    } else if ('object' !== typeof user) {\n      // invalid user object\n      return []\n    }\n\n    if (!user || !user.roles) return []\n\n    if (group) {\n      return _.union(user.roles[group] || [], user.roles[Roles.GLOBAL_GROUP] || [])\n    }\n\n    if (_.isArray(user.roles))\n      return user.roles\n\n    // using groups but group not specified. return global group, if exists\n    return user.roles[Roles.GLOBAL_GROUP] || []\n  },\n\n  /**\n   * Retrieve set of all existing roles\n   *\n   * @method getAllRoles\n   * @return {Cursor} cursor of existing roles\n   */\n  getAllRoles: function () {\n    return Meteor.roles.find({}, {sort: {name: 1}})\n  },\n\n  /**\n   * Retrieve all users who are in target role.  \n   *\n   * NOTE: This is an expensive query; it performs a full collection scan\n   * on the users collection since there is no index set on the 'roles' field.  \n   * This is by design as most queries will specify an _id so the _id index is \n   * used automatically.\n   *\n   * @method getUsersInRole\n   * @param {Array|String} role Name of role/permission.  If array, users \n   *                            returned will have at least one of the roles\n   *                            specified but need not have _all_ roles.\n   * @param {String} [group] Optional name of group to restrict roles to.\n   *                         User's Roles.GLOBAL_GROUP will also be checked.\n   * @return {Cursor} cursor of users in role\n   */\n  getUsersInRole: function (role, group) {\n    var query,\n        roles = role,\n        groupQuery\n\n    // ensure array to simplify query logic\n    if (!_.isArray(roles)) roles = [roles]\n    \n    if (group) {\n      if ('string' !== typeof group)\n        throw new Error (\"Roles error: Invalid parameter 'group'. Expected 'string' type\")\n      if ('$' === group[0])\n        throw new Error (\"Roles error: groups can not start with '$'\")\n\n      // convert any periods to underscores\n      group = group.replace(/\\./g, '_')\n    }\n\n    query = {$or: []}\n\n    // always check Roles.GLOBAL_GROUP\n    groupQuery = {}\n    groupQuery['roles.'+Roles.GLOBAL_GROUP] = {$in: roles}\n    query.$or.push(groupQuery)\n\n    if (group) {\n      // structure of query, when group specified including Roles.GLOBAL_GROUP \n      //   {\n      //    $or: [\n      //      {'roles.group1':{$in: ['admin']}},\n      //      {'roles.__global_roles__':{$in: ['admin']}}\n      //    ]}\n      groupQuery = {}\n      groupQuery['roles.'+group] = {$in: roles}\n      query.$or.push(groupQuery)\n    } else {\n      // structure of query, where group not specified. includes \n      // Roles.GLOBAL_GROUP \n      //   {\n      //    $or: [\n      //      {roles: {$in: ['admin']}},\n      //      {'roles.__global_roles__': {$in: ['admin']}}\n      //    ]}\n      query.$or.push({roles: {$in: roles}})\n    }\n\n    return Meteor.users.find(query)\n  },  // end getUsersInRole \n  \n  /**\n   * Retrieve users groups, if any\n   *\n   * @method getGroupsForUser\n   * @param {String|Object} user User Id or actual user object\n   * @param {String} [role] Optional name of roles to restrict groups to.\n   *\n   * @return {Array} Array of user's groups, unsorted. Roles.GLOBAL_GROUP will be omitted\n   */\n  getGroupsForUser: function (user, role) {\n    var userGroups = [];\n    \n    if (!user) return []\n    if (role) {\n      if ('string' !== typeof role) return []\n      if ('$' === role[0]) return []\n\n      // convert any periods to underscores\n      role = role.replace('.', '_')\n    }\n\n    if ('string' === typeof user) {\n      user = Meteor.users.findOne(\n               {_id: user},\n               {fields: {roles: 1}})\n    \n    }else if ('object' !== typeof user) {\n      // invalid user object\n      return []\n    }\n\n    //User has no roles or is not using groups\n    if (!user || !user.roles || _.isArray(user.roles)) return []\n\n    if (role) {\n      _.each(user.roles, function(groupRoles, groupName) {\n        if (_.contains(groupRoles, role) && groupName !== Roles.GLOBAL_GROUP) {\n          userGroups.push(groupName);\n        }\n      });\n      return userGroups;\n    }else {\n      return _.without(_.keys(user.roles), Roles.GLOBAL_GROUP);\n    }\n\n  }, //End getGroupsForUser\n\n\n  /**\n   * Private function 'template' that uses $set to construct an update object\n   * for MongoDB.  Passed to _updateUserRoles\n   *\n   * @method _update_$set_fn \n   * @protected\n   * @param {Array} roles\n   * @param {String} [group]\n   * @return {Object} update object for use in MongoDB update command\n   */\n  _update_$set_fn: function  (roles, group) {\n    var update = {}\n\n    if (group) {\n      // roles is a key/value dict object\n      update.$set = {}\n      update.$set['roles.' + group] = roles\n    } else {\n      // roles is an array of strings\n      update.$set = {roles: roles}\n    }\n\n    return update\n  },  // end _update_$set_fn \n\n  /**\n   * Private function 'template' that uses $addToSet to construct an update \n   * object for MongoDB.  Passed to _updateUserRoles\n   *\n   * @method _update_$addToSet_fn  \n   * @protected\n   * @param {Array} roles\n   * @param {String} [group]\n   * @return {Object} update object for use in MongoDB update command\n   */\n  _update_$addToSet_fn: function (roles, group) {\n    var update = {}\n\n    if (group) {\n      // roles is a key/value dict object\n      update.$addToSet = {}\n      update.$addToSet['roles.' + group] = {$each: roles}\n    } else {\n      // roles is an array of strings\n      update.$addToSet = {roles: {$each: roles}}\n    }\n\n    return update\n  },  // end _update_$addToSet_fn \n\n\n  /**\n   * Internal function that users the Template pattern to adds or sets roles \n   * for users.\n   *\n   * @method _updateUserRoles\n   * @protected\n   * @param {Array|String} users user id(s) or object(s) with an _id field\n   * @param {Array|String} roles name(s) of roles/permissions to add users to\n   * @param {String} group Group name. If not null or undefined, roles will be\n   *                         specific to that group.  \n   *                         Group names can not start with '$'.\n   *                         Periods in names '.' are automatically converted\n   *                         to underscores.\n   *                         The special group Roles.GLOBAL_GROUP provides \n   *                         a convenient way to assign blanket roles/permissions\n   *                         across all groups.  The roles/permissions in the \n   *                         Roles.GLOBAL_GROUP group will be automatically \n   *                         included in checks for any group.\n   * @param {Function} updateFactory Func which returns an update object that\n   *                         will be passed to Mongo.\n   *   @param {Array} roles\n   *   @param {String} [group]\n   */\n  _updateUserRoles: function (users, roles, group, updateFactory) {\n    if (!users) throw new Error (\"Missing 'users' param\")\n    if (!roles) throw new Error (\"Missing 'roles' param\")\n    if (group) {\n      if ('string' !== typeof group)\n        throw new Error (\"Roles error: Invalid parameter 'group'. Expected 'string' type\")\n      if ('$' === group[0])\n        throw new Error (\"Roles error: groups can not start with '$'\")\n\n      // convert any periods to underscores\n      group = group.replace(/\\./g, '_')\n    }\n\n    var existingRoles,\n        query,\n        update\n\n    // ensure arrays to simplify code\n    if (!_.isArray(users)) users = [users]\n    if (!_.isArray(roles)) roles = [roles]\n\n    // remove invalid roles\n    roles = _.reduce(roles, function (memo, role) {\n      if (role\n          && 'string' === typeof role\n          && role.trim().length > 0) {\n        memo.push(role.trim())\n      }\n      return memo\n    }, [])\n\n    // empty roles array is ok, since it might be a $set operation to clear roles\n    //if (roles.length === 0) return\n\n    // ensure all roles exist in 'roles' collection\n    existingRoles = _.reduce(Meteor.roles.find({}).fetch(), function (memo, role) {\n      memo[role.name] = true\n      return memo\n    }, {})\n    _.each(roles, function (role) {\n      if (!existingRoles[role]) {\n        Roles.createRole(role)\n      }\n    })\n\n    // ensure users is an array of user ids\n    users = _.reduce(users, function (memo, user) {\n      var _id\n      if ('string' === typeof user) {\n        memo.push(user)\n      } else if ('object' === typeof user) {\n        _id = user._id\n        if ('string' === typeof _id) {\n          memo.push(_id)\n        }\n      }\n      return memo\n    }, [])\n    \n    // update all users\n    update = updateFactory(roles, group)\n    \n    try {\n      if (Meteor.isClient) {\n        // On client, iterate over each user to fulfill Meteor's \n        // 'one update per ID' policy\n        _.each(users, function (user) {\n          Meteor.users.update({_id: user}, update)\n        })\n      } else {\n        // On the server we can use MongoDB's $in operator for \n        // better performance\n        Meteor.users.update(\n          {_id: {$in: users}},\n          update,\n          {multi: true})\n      }\n    }\n    catch (ex) {\n      var addNonGroupToGroupedRolesMsg = 'Cannot apply $addToSet modifier to non-array',\n          addGrouped2NonGroupedMsg = \"can't append to array using string field name\"\n\n      if (ex.name === 'MongoError' &&\n          (ex.err === addNonGroupToGroupedRolesMsg ||\n           ex.err.substring(0, 45) === addGrouped2NonGroupedMsg)) {\n        throw new Error (mixingGroupAndNonGroupErrorMsg)\n      }\n\n      throw ex\n    }\n  }  // end _updateUserRoles\n\n})  // end _.extend(Roles ...)\n\n}());\n"]}