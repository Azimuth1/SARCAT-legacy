{"version":3,"sources":["service-configuration/service_configuration_common.js","service-configuration/service_configuration_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,kD;AACA,4B;AACA,C;;;AAGA,iE;AACA,gB;AACA,2D;AACA,gD;AACA,8B;AACA,yE;AACA,K;AACA,wE;AACA,uE;AACA,mE;AACA,qE;AACA,Q;;;AAGA,oE;AACA,2D;AACA,+D;AACA,gE;AACA,2B;AACA,gE;AACA,U;AACA,4C;AACA,G;AACA,E;AACA,yD;AACA,qF;;;;;;;;;;;;;;;;;;;AC9BA,6D;AACA,iE;AACA,4E;AACA,wE;AACA,K;AACA,qD;AACA,yB;AACA,wB;AACA,M;AACA,e;AACA,kB;AACA,4E;AACA,gF;AACA,uE;AACA,kF;AACA,uE;AACA,yE;AACA,oF;AACA,kF;AACA,gF;AACA,2E;AACA,gF;AACA,kC;AACA,8E;AACA,gF;AACA,2E;AACA,uD;AACA,M;AACA,c;AACA,C","file":"/packages/service-configuration.js","sourcesContent":["if (typeof ServiceConfiguration === 'undefined') {\n  ServiceConfiguration = {};\n}\n\n\n// Table containing documents with configuration options for each\n// login service\nServiceConfiguration.configurations = new Mongo.Collection(\n  \"meteor_accounts_loginServiceConfiguration\", {\n    _preventAutopublish: true,\n    connection: Meteor.isClient ? Accounts.connection : Meteor.connection\n  });\n// Leave this collection open in insecure mode. In theory, someone could\n// hijack your oauth connect requests to a different endpoint or appId,\n// but you did ask for 'insecure'. The advantage is that it is much\n// easier to write a configuration wizard that works only in insecure\n// mode.\n\n\n// Thrown when trying to use a login service which is not configured\nServiceConfiguration.ConfigError = function (serviceName) {\n  if (Meteor.isClient && !Accounts.loginServicesConfigured()) {\n    this.message = \"Login service configuration not yet loaded\";\n  } else if (serviceName) {\n    this.message = \"Service \" + serviceName + \" not configured\";\n  } else {\n    this.message = \"Service not configured\";\n  }\n};\nServiceConfiguration.ConfigError.prototype = new Error();\nServiceConfiguration.ConfigError.prototype.name = 'ServiceConfiguration.ConfigError';\n","// Only one configuration should ever exist for each service.\n// A unique index helps avoid various race conditions which could\n// otherwise lead to an inconsistent database state (when there are multiple\n// configurations for a single service, which configuration is correct?)\ntry {\n    ServiceConfiguration.configurations._ensureIndex(\n        { \"service\": 1 },\n        { unique: true }\n    );\n} catch (err) {\n    console.error(\n        \"The service-configuration package persists configuration in the \" +\n        \"meteor_accounts_loginServiceConfiguration collection in MongoDB. As \" +\n        \"each service should have exactly one configuration, Meteor \" +\n        \"automatically creates a MongoDB index with a unique constraint on the \" +\n        \" meteor_accounts_loginServiceConfiguration collection. The \" +\n        \"_ensureIndex command which creates that index is failing.\\n\\n\" +\n        \"Meteor versions before 1.0.4 did not create this index. If you recently \" +\n        \"upgraded and are seeing this error message for the first time, please \" +\n        \"check your meteor_accounts_loginServiceConfiguration collection for \" +\n        \"multiple configuration entries for the same service and delete \" +\n        \"configuration entries until there is no more than one configuration \" +\n        \"entry per service.\\n\\n\" +\n        \"If the meteor_accounts_loginServiceConfiguration collection looks \" +\n        \"fine, the _ensureIndex command is failing for some other reason.\\n\\n\" +\n        \"For more information on this history of this issue, please see \" +\n        \"https://github.com/meteor/meteor/pull/3514.\\n\"\n    );\n    throw err;\n}\n"]}